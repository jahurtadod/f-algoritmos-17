	<!doctype html>
	<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js - Constructor</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/night.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">

				<section>
					<h2>Recursividad</h1>
						<h5>PROGRAMACIÓN DE ALGORITMOS [A]</h5>
						<p>
							<small>Created by Jorge Hurtado</a> / <a href="https://github.com/jahurtadod">jahurtadod</a></small>
						</p>
					</section>

					<section>
						<section>
							<p>
								Se conoce como un método recursivo a aquellos métodos que se llaman a sí mismos, ya sea de forma directa o indirecta. 
							</p>
							<br>
						</section>
						<section>
							<ul>
								<li>De manera directa el método se llama a sí mismo en algún momento de su ejecución.
								</li>
								<p></p>
								<li>De manera indirecta el método llama a otro método, que a su vez puede hacer una llamada de vuelta al método recursivo.</li>
							</ul>
						</section>
					</section>

					<section>
						<h4>
							Características de un método recursivo:
						</h4>
						<ul>
							<li>De manera directa el método se llama a sí mismo en algún momento de su ejecución.
							</li>
							<p></p>
							<li>De manera indirecta el método llama a otro método, que a su vez puede hacer una llamada de vuelta al método recursivo.</li>
						</ul>
					</section>

					<section data-transition="slide" data-background="#263238">
						<section>
							<p>
								En otras palabras, este concepto de la recursividad separa el problema en dos porciones más pequeñas es una forma del método “divide y vencerás”.
							</p>
						</section>
					</section>

					<section>
						<section>
							<h2></h2>
							<p>
								Se pueden producir muchas llamadas recursivas más, a medida que el método divide cada nuevo subproblema en dos piezas. 
								<p>
									Para que la recursividad termine en un momento dado, la secuencia de problemas cada vez más pequeños debe converger en un caso base.
									<p>
										Después se origina una secuencia de retornos, hasta que la llamada al método original devuelve el resultado final al método que lo llamó.
									</p>
								</section>
							</section>

							<section data-transition="slide" data-background="#263238">
								<section>
									<p>
										Ejemplo de Recursividad: 
									</p>
									<pre><code class="Java" data-trim contenteditable>
										public class CalculoFactorial {
											// declaración recursiva del método factorial
											public long factorial ( long numero ) {
												if ( numero <= 1 ) // evalúa el caso base
													return 1; // casos base: 0! = 1 y 1! = 1
												else // paso recursivo
													return numero * factorial( numero - 1 );
											} // fin del método factorial
											// imprime factoriales para los valores del 0 al 10
											public void mostrarFactoriales () {
												// calcula los factoriales del 0 al 10
												for ( int contador = 0; contador <= 10; contador++ )
													System.out.printf( "%d! = %d\n", contador, factorial( contador ) );
											} // fin del método mostrarFactoriales
										} // fin de la clase CalculoFactorial
						</code></pre>
					</section>
				</section>

				<section data-transition="slide" data-background="#263238">
					<section>
						<h2></h2>
						<p>
							La Recursividad permite programar algoritmos aparentemente complicados con un código simple y claro. A simple vista parece la forma más optima de dar solución a muchos problemas, pero hay que tener en cuenta que en ocasiones ralentizará el programa en exceso. Por lo que es necesario saber diferenciar cuando es útil y cuando no.
						</p>
					</section>
				</section>

					
					<section style="text-align: left;">
						<h3>BIBLIOGRAFÍA</h1>
							<p>
								- <a>Joyanes Aguilar, L., & Aguilar, L. J. (2003). Fundamentos de programación: algoritmos y estructura de datos y objetos.</a> <br>
								- <a>Deitel, P. J. D., Deitel, H. M., & Deitel, H. M. (2008). Java: cómo programar. Pearson Educación.</a> <br>
								- <a>Fernández, O. B. (2010). Introducción al lenguaje de programación Java. Universitat Jaume, España.</a> <br> 	
							</p>
						</section>

					</div>
				</div>

				<script src="lib/js/head.min.js"></script>
				<script src="js/reveal.js"></script>

				<script>
				// More info about config & dependencies:
				// - https://github.com/hakimel/reveal.js#configuration
				// - https://github.com/hakimel/reveal.js#dependencies
				Reveal.initialize({
					controls: true,
					progress: true,
					history: true,
					center: true,

					transition: 'convex',

					dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
					]
				});
			</script>
		</body>
		</html>
